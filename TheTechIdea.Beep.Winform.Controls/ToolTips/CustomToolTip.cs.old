using System;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using TheTechIdea.Beep.Vis.Modules;
using Timer = System.Windows.Forms.Timer;

namespace TheTechIdea.Beep.Winform.Controls.ToolTips
{
    /// <summary>
    /// Modern custom tooltip with rich styling, animations, and smart positioning
    /// Inspired by DevExpress, Material-UI, Ant Design tooltips
    /// </summary>
    public class CustomToolTip : Form
    {
        private ToolTipConfig _config;
        private Timer _animationTimer;
        private float _opacity = 0f;
        private bool _isShowing = false;
        private bool _isHiding = false;
        private readonly int _shadowOffset = 4;
        private readonly int _arrowSize = 8;
        private Point _arrowPosition;
        private ToolTipPlacement _actualPlacement;

        public CustomToolTip()
        {
            InitializeTooltip();
        }

        private void InitializeTooltip()
        {
            // Form setup for modern tooltip
            SetStyle(ControlStyles.AllPaintingInWmPaint | 
                     ControlStyles.UserPaint | 
                     ControlStyles.OptimizedDoubleBuffer | 
                     ControlStyles.SupportsTransparentBackColor, true);
            
            FormBorderStyle = FormBorderStyle.None;
            ShowInTaskbar = false;
            TopMost = true;
            BackColor = Color.FromArgb(45, 45, 48); // Dark theme default
            Opacity = 0;
            StartPosition = FormStartPosition.Manual;
            
            // Animation timer
            _animationTimer = new Timer { Interval = 16 }; // ~60fps
            _animationTimer.Tick += OnAnimationTick;
        }

        public void ApplyConfig(ToolTipConfig config)
        {
            _config = config ?? throw new ArgumentNullException(nameof(config));
            
            // Apply theming
            ApplyTheme(_config.Theme);
            
            // Calculate size based on content
            CalculateSize();
            
            // Update display
            Invalidate();
        }

        private void ApplyTheme(ToolTipTheme theme)
        {
            switch (theme)
            {
                case ToolTipTheme.Light:
                    BackColor = Color.FromArgb(255, 255, 255);
                    ForeColor = Color.FromArgb(33, 33, 33);
                    break;
                case ToolTipTheme.Dark:
                    BackColor = Color.FromArgb(45, 45, 48);
                    ForeColor = Color.FromArgb(241, 241, 241);
                    break;
                case ToolTipTheme.Primary:
                    BackColor = Color.FromArgb(64, 158, 255);
                    ForeColor = Color.White;
                    break;
                case ToolTipTheme.Success:
                    BackColor = Color.FromArgb(82, 196, 26);
                    ForeColor = Color.White;
                    break;
                case ToolTipTheme.Warning:
                    BackColor = Color.FromArgb(250, 173, 20);
                    ForeColor = Color.FromArgb(33, 33, 33);
                    break;
                case ToolTipTheme.Error:
                    BackColor = Color.FromArgb(245, 63, 63);
                    ForeColor = Color.White;
                    break;
                case ToolTipTheme.Info:
                    BackColor = Color.FromArgb(24, 144, 255);
                    ForeColor = Color.White;
                    break;
                case ToolTipTheme.Custom:
                    if (_config.BackColor.HasValue) BackColor = _config.BackColor.Value;
                    if (_config.ForeColor.HasValue) ForeColor = _config.ForeColor.Value;
                    break;
                case ToolTipTheme.Auto:
                default:
                    // Auto-detect based on system theme or parent control
                    ApplyAutoTheme();
                    break;
            }
        }

        private void ApplyAutoTheme()
        {
            // Simple dark/light detection based on system colors
            var systemBg = SystemColors.Window;
            var brightness = (systemBg.R * 0.299 + systemBg.G * 0.587 + systemBg.B * 0.114);
            
            if (brightness < 128)
            {
                ApplyTheme(ToolTipTheme.Dark);
            }
            else
            {
                ApplyTheme(ToolTipTheme.Light);
            }
        }

        private void CalculateSize()
        {
            if (_config == null) return;

            using var g = CreateGraphics();
            var font = _config.Font ?? new Font("Segoe UI", 9f);
            
            // Measure content
            var textSize = Size.Empty;
            var titleSize = Size.Empty;
            
            if (!string.IsNullOrEmpty(_config.Text))
            {
                var maxWidth = _config.MaxSize?.Width ?? 300;
                textSize = TextRenderer.MeasureText(g, _config.Text, font, 
                    new Size(maxWidth, int.MaxValue), TextFormatFlags.WordBreak);
            }
            
            if (!string.IsNullOrEmpty(_config.Title))
            {
                var titleFont = new Font(font.FontFamily, font.Size + 2, FontStyle.Bold);
                titleSize = TextRenderer.MeasureText(g, _config.Title, titleFont);
            }

            // Calculate total size with padding
            var padding = 12;
            var iconSpace = (_config.Icon != null || !string.IsNullOrEmpty(_config.IconPath)) ? 24 : 0;
            var titleSpacing = !string.IsNullOrEmpty(_config.Title) ? 8 : 0;
            
            var width = Math.Max(textSize.Width, titleSize.Width) + padding * 2 + iconSpace;
            var height = textSize.Height + titleSize.Height + titleSpacing + padding * 2;
            
            // Apply constraints
            if (_config.MaxSize.HasValue)
            {
                width = Math.Min(width, _config.MaxSize.Value.Width);
                height = Math.Min(height, _config.MaxSize.Value.Height);
            }
            
            Size = new Size(width + _shadowOffset, height + _shadowOffset);
        }

        public async Task ShowAsync(Point position, CancellationToken cancellationToken = default)
        {
            if (_isShowing) return;
            
            _isShowing = true;
            _isHiding = false;

            // Smart positioning
            CalculateOptimalPosition(position);
            
            // Show the form
            Show();
            
            // Animate in
            if (ToolTipManager.EnableAnimations)
            {
                await AnimateInAsync(_config.Animation, cancellationToken);
            }
            else
            {
                Opacity = 1.0;
            }
        }

        public async Task HideAsync()
        {
            if (_isHiding || !_isShowing) return;
            
            _isHiding = true;
            
            // Animate out
            if (ToolTipManager.EnableAnimations && Visible)
            {
                await AnimateOutAsync(_config.Animation);
            }
            
            Hide();
            _isShowing = false;
            _isHiding = false;
        }

        private void CalculateOptimalPosition(Point targetPosition)
        {
            var screen = Screen.FromPoint(targetPosition);
            var screenBounds = screen.WorkingArea;
            
            var tooltipSize = Size;
            var preferredPlacement = _config.Placement;
            
            // Try preferred placement first
            var position = CalculatePositionForPlacement(targetPosition, preferredPlacement, tooltipSize);
            var bounds = new Rectangle(position, tooltipSize);
            
            // If it fits, use it
            if (screenBounds.Contains(bounds))
            {
                Location = position;
                _actualPlacement = preferredPlacement;
                return;
            }
            
            // Try alternative placements
            var placements = new []
            {
                ToolTipPlacement.Top, ToolTipPlacement.Bottom,
                ToolTipPlacement.Right, ToolTipPlacement.Left,
                ToolTipPlacement.TopStart, ToolTipPlacement.TopEnd,
                ToolTipPlacement.BottomStart, ToolTipPlacement.BottomEnd
            };
            
            foreach (var placement in placements)
            {
                position = CalculatePositionForPlacement(targetPosition, placement, tooltipSize);
                bounds = new Rectangle(position, tooltipSize);
                
                if (screenBounds.Contains(bounds))
                {
                    Location = position;
                    _actualPlacement = placement;
                    return;
                }
            }
            
            // Fallback: clamp to screen
            position = CalculatePositionForPlacement(targetPosition, ToolTipPlacement.Top, tooltipSize);
            position.X = Math.Max(screenBounds.Left, Math.Min(position.X, screenBounds.Right - tooltipSize.Width));
            position.Y = Math.Max(screenBounds.Top, Math.Min(position.Y, screenBounds.Bottom - tooltipSize.Height));
            
            Location = position;
            _actualPlacement = ToolTipPlacement.Top;
        }

        private Point CalculatePositionForPlacement(Point target, ToolTipPlacement placement, Size tooltipSize)
        {
            var offset = 8; // Distance from target
            
            return placement switch
            {
                ToolTipPlacement.Top => new Point(target.X - tooltipSize.Width / 2, target.Y - tooltipSize.Height - offset),
                ToolTipPlacement.TopStart => new Point(target.X, target.Y - tooltipSize.Height - offset),
                ToolTipPlacement.TopEnd => new Point(target.X - tooltipSize.Width, target.Y - tooltipSize.Height - offset),
                ToolTipPlacement.Bottom => new Point(target.X - tooltipSize.Width / 2, target.Y + offset),
                ToolTipPlacement.BottomStart => new Point(target.X, target.Y + offset),
                ToolTipPlacement.BottomEnd => new Point(target.X - tooltipSize.Width, target.Y + offset),
                ToolTipPlacement.Left => new Point(target.X - tooltipSize.Width - offset, target.Y - tooltipSize.Height / 2),
                ToolTipPlacement.LeftStart => new Point(target.X - tooltipSize.Width - offset, target.Y),
                ToolTipPlacement.LeftEnd => new Point(target.X - tooltipSize.Width - offset, target.Y - tooltipSize.Height),
                ToolTipPlacement.Right => new Point(target.X + offset, target.Y - tooltipSize.Height / 2),
                ToolTipPlacement.RightStart => new Point(target.X + offset, target.Y),
                ToolTipPlacement.RightEnd => new Point(target.X + offset, target.Y - tooltipSize.Height),
                _ => new Point(target.X - tooltipSize.Width / 2, target.Y - tooltipSize.Height - offset)
            };
        }

        private async Task AnimateInAsync(ToolTipAnimation animation, CancellationToken cancellationToken)
        {
            const int duration = 150;
            const int steps = 15;
            var stepDelay = duration / steps;
            
            switch (animation)
            {
                case ToolTipAnimation.Fade:
                    for (int i = 0; i <= steps; i++)
                    {
                        if (cancellationToken.IsCanceled) return;
                        Opacity = (double)i / steps;
                        await Task.Delay(stepDelay, cancellationToken);
                    }
                    break;
                    
                case ToolTipAnimation.Scale:
                    var originalSize = Size;
                    for (int i = 0; i <= steps; i++)
                    {
                        if (cancellationToken.IsCanceled) return;
                        var scale = (double)i / steps;
                        var newSize = new Size(
                            (int)(originalSize.Width * scale),
                            (int)(originalSize.Height * scale));
                        Size = newSize;
                        Opacity = scale;
                        await Task.Delay(stepDelay, cancellationToken);
                    }
                    Size = originalSize;
                    break;
                    
                default:
                    Opacity = 1.0;
                    break;
            }
        }

        private async Task AnimateOutAsync(ToolTipAnimation animation)
        {
            const int duration = 100;
            const int steps = 10;
            var stepDelay = duration / steps;
            
            switch (animation)
            {
                case ToolTipAnimation.Fade:
                    for (int i = steps; i >= 0; i--)
                    {
                        Opacity = (double)i / steps;
                        await Task.Delay(stepDelay);
                    }
                    break;
                    
                default:
                    Opacity = 0;
                    break;
            }
        }

        public void UpdatePosition(Point newPosition)
        {
            CalculateOptimalPosition(newPosition);
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            if (_config == null) return;
            
            var g = e.Graphics;
            g.SmoothingMode = SmoothingMode.AntiAlias;
            g.TextRenderingHint = System.Drawing.Text.TextRenderingHint.ClearTypeGridFit;

            var contentRect = new Rectangle(0, 0, Width - _shadowOffset, Height - _shadowOffset);
            
            // Draw shadow
            if (_config.EnableShadow)
            {
                DrawShadow(g, contentRect);
            }
            
            // Draw background
            DrawBackground(g, contentRect);
            
            // Draw arrow
            if (_config.ShowArrow)
            {
                DrawArrow(g, contentRect);
            }
            
            // Draw content
            DrawContent(g, contentRect);
        }

        private void DrawShadow(Graphics g, Rectangle bounds)
        {
            var shadowRect = new Rectangle(bounds.X + _shadowOffset, bounds.Y + _shadowOffset, 
                                         bounds.Width, bounds.Height);
            
            using var shadowBrush = new SolidBrush(Color.FromArgb(40, 0, 0, 0));
            using var path = CreateRoundedPath(shadowRect, 6);
            g.FillPath(shadowBrush, path);
        }

        private void DrawBackground(Graphics g, Rectangle bounds)
        {
            using var backgroundBrush = new SolidBrush(BackColor);
            using var path = CreateRoundedPath(bounds, 6);
            g.FillPath(backgroundBrush, path);
            
            // Border
            if (_config.BorderColor.HasValue)
            {
                using var borderPen = new Pen(_config.BorderColor.Value);
                g.DrawPath(borderPen, path);
            }
        }

        private void DrawArrow(Graphics g, Rectangle bounds)
        {
            // Calculate arrow position based on placement
            var arrowPoints = CalculateArrowPoints(bounds);
            if (arrowPoints.Length > 0)
            {
                using var arrowBrush = new SolidBrush(BackColor);
                g.FillPolygon(arrowBrush, arrowPoints);
            }
        }

        private Point[] CalculateArrowPoints(Rectangle bounds)
        {
            var arrowSize = _arrowSize;
            
            return _actualPlacement switch
            {
                ToolTipPlacement.Top or ToolTipPlacement.TopStart or ToolTipPlacement.TopEnd =>
                    new[] {
                        new Point(bounds.X + bounds.Width / 2, bounds.Bottom),
                        new Point(bounds.X + bounds.Width / 2 - arrowSize, bounds.Bottom - arrowSize),
                        new Point(bounds.X + bounds.Width / 2 + arrowSize, bounds.Bottom - arrowSize)
                    },
                ToolTipPlacement.Bottom or ToolTipPlacement.BottomStart or ToolTipPlacement.BottomEnd =>
                    new[] {
                        new Point(bounds.X + bounds.Width / 2, bounds.Top),
                        new Point(bounds.X + bounds.Width / 2 - arrowSize, bounds.Top + arrowSize),
                        new Point(bounds.X + bounds.Width / 2 + arrowSize, bounds.Top + arrowSize)
                    },
                _ => Array.Empty<Point>()
            };
        }

        private void DrawContent(Graphics g, Rectangle bounds)
        {
            var padding = 12;
            var contentRect = new Rectangle(bounds.X + padding, bounds.Y + padding,
                                          bounds.Width - padding * 2, bounds.Height - padding * 2);
            
            var font = _config.Font ?? new Font("Segoe UI", 9f);
            var y = contentRect.Y;
            
            // Draw icon
            if (_config.Icon != null || !string.IsNullOrEmpty(_config.IconPath))
            {
                // TODO: Draw icon
                contentRect.X += 24;
                contentRect.Width -= 24;
            }
            
            // Draw title
            if (!string.IsNullOrEmpty(_config.Title))
            {
                using var titleFont = new Font(font.FontFamily, font.Size + 2, FontStyle.Bold);
                using var titleBrush = new SolidBrush(ForeColor);
                
                var titleRect = new Rectangle(contentRect.X, y, contentRect.Width, 0);
                var titleSize = TextRenderer.MeasureText(g, _config.Title, titleFont, contentRect.Size);
                titleRect.Height = titleSize.Height;
                
                TextRenderer.DrawText(g, _config.Title, titleFont, titleRect, ForeColor,
                    TextFormatFlags.Left | TextFormatFlags.Top | TextFormatFlags.WordBreak);
                
                y += titleSize.Height + 8;
            }
            
            // Draw text
            if (!string.IsNullOrEmpty(_config.Text))
            {
                using var textBrush = new SolidBrush(ForeColor);
                var textRect = new Rectangle(contentRect.X, y, contentRect.Width, contentRect.Bottom - y);
                
                TextRenderer.DrawText(g, _config.Text, font, textRect, ForeColor,
                    TextFormatFlags.Left | TextFormatFlags.Top | TextFormatFlags.WordBreak);
            }
        }

        private GraphicsPath CreateRoundedPath(Rectangle rect, int radius)
        {
            var path = new GraphicsPath();
            int d = Math.Min(radius * 2, Math.Min(rect.Width, rect.Height));
            
            if (d <= 1)
            {
                path.AddRectangle(rect);
                return path;
            }
            
            var arc = new Rectangle(rect.X, rect.Y, d, d);
            path.AddArc(arc, 180, 90);
            arc.X = rect.Right - d;
            path.AddArc(arc, 270, 90);
            arc.Y = rect.Bottom - d;
            path.AddArc(arc, 0, 90);
            arc.X = rect.Left;
            path.AddArc(arc, 90, 90);
            path.CloseFigure();
            
            return path;
        }

        private void OnAnimationTick(object sender, EventArgs e)
        {
            // Animation tick handler for smooth animations
        }

        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                _animationTimer?.Stop();
                _animationTimer?.Dispose();
            }
            base.Dispose(disposing);
        }

        // Legacy compatibility methods
        public void SetText(string text)
        {
            _config ??= new ToolTipConfig();
            _config.Text = text;
            ApplyConfig(_config);
        }

        public void Show(Point location)
        {
            _ = ShowAsync(location);
        }
    }
}
